
## 2.5 进程间通信
### 2.5.1 进程间通信简介

`什么是进程间通信`

进程之间相互发送和接收数据

`进程间通信的目的`

- 数据传输
- 通知事件：下载完之后有弹窗
- 资源共享：两个窗口可以打开同一个文件夹、文件
- 进程控制：如DEBUG、资源管理器结束某个程序的进程

`进程间通信的方式`

![](../pic/2-5-1.png)

### 2.5.2 匿名管道
`匿名管道的介绍`

![](../pic/2-5-2.png)

`匿名管道的特点`

![](../pic/2-5-3.png)

![](../pic/2-5-4.png)

`使用匿名管道实现进程间通信的原理`

![](../pic/2-5-5.png)

`管道的数据结构`

![](../pic/2-5-6.png)

`匿名管道的使用`

```c
#include <unistd.h>
int pipe(int pipefd[2]);

作用：创建一个（匿名）管道文件
参数：pipefd[]是一个数组，执行之后会把数据存到这个数组中
    pipefd[0]:读端fd文件描述符
    pipefd[1]:写端fd文件描述符
返回值：
    0：成功
    -1：失败
注意：
- pipe()只能用于有关系的两个进程，父子进程、兄弟进程、兄弟进程
- 如果pipe里面没有数据，read操作回被阻塞。

```
`案例模拟实现ps aux`
```c
/*
    实现 ps aux | grep xxx 父子进程间通信
    
    子进程： ps aux, 子进程结束后，将数据发送给父进程
    父进程：获取到数据，过滤
    pipe()
    execlp()
    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2
*/

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wait.h>

int main() {

    // 创建一个管道
    int fd[2];
    int ret = pipe(fd);

    if(ret == -1) {
        perror("pipe");
        exit(0);
    }

    // 创建子进程
    pid_t pid = fork();

    if(pid > 0) {
        // 父进程
        // 关闭写端
        close(fd[1]);
        // 从管道中读取
        char buf[1024] = {0};

        int len = -1;
        while((len = read(fd[0], buf, sizeof(buf) - 1)) > 0) {
            // 过滤数据输出
            printf("%s", buf);
            memset(buf, 0, 1024);
        }

        wait(NULL);

    } else if(pid == 0) {
        // 子进程
        // 关闭读端
        close(fd[0]);

        // 文件描述符的重定向 stdout_fileno -> fd[1]
        dup2(fd[1], STDOUT_FILENO);
        // 执行 ps aux
        execlp("ps", "ps", "aux", NULL);
        perror("execlp");
        exit(0);
    } else {
        perror("fork");
        exit(0);
    }


    return 0;
}
```


